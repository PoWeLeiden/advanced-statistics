{"title":"Voorspelde Waarden van Interactiemodellen","markdown":{"yaml":{"code-annotations":"hover"},"headingText":"Voorspelde Waarden van Interactiemodellen","headingAttr":{"id":"sec-predicted-values-from-interaction-models","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n\n\n```{r}\n#| label: setup\n#| echo: false\n#| message: false\n#| warning: false\n\n#Packages\nlibrary(broom)        #Modelresultaten\nlibrary(rio)          #laden van data\nlibrary(tidyverse)    #datamanipulatie en grafieken\nlibrary(marginaleffects) #marginale effecten en voorspelde waarden berekenen\n\n#Data\nanes <- import(\"data/anes_interactions.rda\")\n\n#Modellen\nbiden_int <- lm(biden ~ pid * right_track + rural_urban, data = anes)\nrighttrack_int <- glm(right_track ~ vote2016 * age + rural_urban, \n                      family = \"binomial\", data = anes)\n```\n\n```{r}\n#| eval: false\n\n#Packages\nlibrary(broom)        #Modelresultaten\nlibrary(rio)          #laden van data\nlibrary(tidyverse)    #datamanipulatie en grafieken\nlibrary(marginaleffects) #marginale effecten en voorspelde waarden berekenen\n\n#Data\nanes <- import(\"data/anes_interactions.rda\")\n\n#Modellen\nbiden_int <- lm(biden ~ pid * right_track + rural_urban, data = anes)\nrighttrack_int <- glm(right_track ~ vote2016 * age + rural_urban, \n                      family = \"binomial\", data = anes)\n```\n\nWe kunnen marginale effecten gebruiken om interactie-effecten te verduidelijken zoals we in het vorige hoofdstuk gezien hebben. Maar we kunnen ook kijken naar voorspelde waarden (of kansen bij logistische regressie) van Y als een onafhankelijke variabele X en een onafhankelijke variable Z (de moderator) andere waarden aannemen. We gebruiken de `predictions()` functie uit het `marginaleffects` package. We bouwen verder op reeds geziene informatie in andere hoofdstukken (lineaire regressie: @sec-predicted-residual-values; logistische regressie: @sec-logit-predicted-probabilities).\n\n## Binaire X Continue Interactie\n\nWe hebben reeds een model geschat waarbij scores voor kandidaat Biden voorspeld worden met een interactie van partij-identificatie (pid) en perceptie over de richting dat het land uitgaat (right_track).\n\nOp basis van dit model (biden_int), berekenen we nu met `predictions()` de voorspelde waarden voor elke combinatie van waarden voor de 2 onafhankelijke variabelen in de interactie (bv. pid = 1 & right_track = \"Right Direction\", pid = 1 & right_track = \"Wrong Track\", pid = 2 & right_track = \"Right Direction\"...). Als er te veel waarden zouden zijn om realistisch op deze manier te werk te gaan dan kiezen we voorspellingen op basis van een subset van waarden (bv. minimum, gemiddelde, maximum).\n\nAndere onafhankelijke variabelen in het model worden op hun gemiddelde (continue variabelen) of modus (factor variabelen) gehouden.\n\n```{r}\n#Voorspelde waarden berekenen en opslaan in data object\nbiden_int_preds <- predictions(biden_int, \n            newdata = datagrid(pid = c(1,2,3,4,5,6,7), \n                               right_track = c(\"Right Direction\", \"Wrong Track\")))\n\n```\n\n`biden_int_preds <- predictions(biden_int,`\n\n:   We passen de functie 'predictions' toe op het model tussen haakjes en slaan de resultaten op in een data object (\"biden_int_preds\") dat we later weer kunnen gebruiken.\n\n`newdata = datagrid(pid = c(1,2,...7), right_track = c(\"Right Direction\", \"Wrong Track\")))`\n\n:   We duiden de gewenste waarden van de predictoren aan waarvoor voorspellingen berekend zullen worden met de \"newdata = datagrid()\" optie. We duiden alle waarden voor pid aan (1 tot 7) en de 2 mogelijke waarden voor right_track (Right Direction or Wrong Track).[^interaction_03-1] In eigen toepassingen wordt dit aangepast volgens de eigen variabelen.\n\n[^interaction_03-1]: De waarden voor pid zouden we ook als volgt kunnen aanduiden: `pid = c(1:7)`.\n\nDe dataset die we verkrijgen heeft 14 rijen met voorspelde waarden: 7 (waarden voor `pid`) * 2 (waarden voor `right_track`).\n\n```{r}\n# print resultaten\nbiden_int_preds\n```\n\nDe voorspellingen kunnen we visueel presenteren in een plot. Het proces dat we volgen is vrijwel hetzelfde als wat we doen voor een model zonder interactie (zie @sec-presenting-linear-regression-predicted-values-plots). Er is echter een belangrijke toevoeging: het `linetype` gedeelte van de syntax, dat enkel gebruikt kan worden indien er een factor variabele is. \n\nVoor we het plot produceren veranderen we de waarden voor right_track naar het Nederlands zodat ze correct worden weergegeven op het plot. Net zoals bij marginale effecten zouden we de code voor predictions (hierboven) ook kunnen combineren met de `ggplot` code via de pipe operator.\n\n```{r}\nbiden_int_preds |>\n  mutate(right_track = recode(right_track, \n                       \"Wrong Track\" = \"Verkeerde richting\",\n                       \"Right Direction\" = \"Goede richting\")) |>\nggplot(aes(x=pid, y=estimate, linetype = right_track)) + \n  geom_line() + \n  geom_ribbon(aes(ymin=conf.low, ymax=conf.high), alpha = 0.2) + \n  labs(title = \"Voorspelde score voor Biden\", \n       x = \"Partij-identificatie\", \n       y = \"Voorspelde waarden\", \n       linetype = \"Richting land\" ) + \n  scale_x_continuous(breaks=c(1,2,3,4,5,6,7))\n```\n\n`ggplot(..., linetype = right_track)) + geom_line() + geom_ribbon(...) +`\n\n:   Dit gedeelte van de syntax is grotendeels ook al gebruikt in eerdere weken. Een belangrijke toevoeging is `linetype = right_track`. Zo vragen we `ggplot()` om de voorspelde waarden voor elke categorie van \"right_track\" weer te geven als verschillende lijnen. We zouden de voorspellingen ook kunnen onderscheiden op een andere manier, bv. met kleur (`color = right_track`). De `linetype` (en `color`) functies werken enkel met factor variabelen. De variabele `right_track`is hier reeds een factor dus we hebben geen verdere data management stappen moeten ondernemen. Zie @sec-linetype-error voor meer informatie.\n\n## Continue X Continue Interactie\n\nOm voorspelde waarden voor interacties tussen continue variabelen te berekenen en te plotten, is het proces iets ingewikkelder, omdat er veel mogelijke combinaties van waarden zijn om voorspellingen voor te maken.\n\nIn het vorige hoofdstuk hebben we het `biden_int2` model gebruikt om Biden scores te voorspellen met een interactie tussen `age` en `socialists`. We schatten dat model opnieuw hieronder.\n\n\n```{r}\n#Model schatten en resultaten opslaan\nbiden_int2 <- lm(biden ~ socialists * age + rural_urban, data = anes)\n\n#resultaten bekijekn\ntidy(biden_int2)\n```\n\nBeide variabelen kunnen veel mogelijke waarden aannemen. We zouden voorspellingen kunnen maken voor waarden van 0 tot 100 voor `socialists` met intervallen van 10, en van 20 tot 80 voor `age`met intervallen van 10. Dit zou ons echter veel waarden opleveren die we moeilijk zouden kunnen plotten (en begrijpen). \n\nWat vaak gebeurt in de praktijk is dat we 1 van de 2 predictoren kiezen en voorspellingen maken voor 3 waarden: het gemiddelde, 1 standaarddeviatie (SD) onder het gemiddelde en 1 standaarddeviatie (SD) boven het gemiddelde. De continue variabele zal eigenlijk getransformeerd worden in een factor met 3 waarden. Zo kunnen we een plot maken met 3 lijnen. We transformeren doorgaans de moderator (Z).\n\nVoor het 'biden_int2' model, nemen we nu (bij wijze van voorbeeld) socialists als de moderator. Eerst berekenen we de drie relevante waarden (gemiddelde, 1 SD daaronder, 1 SD daarboven). Deze statistieken moeten we berekenen op basis van de observaties gebruikt in het model. Dit zijn niet altijd het aantal observaties in de dataset door missende waarden op andere variabelen. Als tussenstap gebruiken we hier de `predictions()` functie van het `marginaleffects` package gezien deze functie een nieuwe dataset creÃ«ert met alle complete observaties. [^interaction_03-2]\n\n[^interaction_03-2]: We zouden ook de originele dataset (`anes`) kunnen nemen, missing waarden voor de variabelen gebruikt in het model wegfilteren en de juiste statistieken berekenen: `anes \\|\\> filter(complete.cases(biden, socialists, age, rural_urban)) \\|\\> summarize(...)`.`predictions()` combineert deze stappen voor ons.\n\n```{r}\npredictions(biden_int2) |>   #nieuw dataobject met complete observaties\n  summarise(\n    mean_below = mean(socialists) - sd(socialists), #1 SD onder gemiddelde\n    mean = mean(socialists),                        #gemiddelde\n    mean_above = mean(socialists) + sd(socialists)) #1 SD boven gemiddelde\n```\n\nNu kunnen we de voorspelde waarden berekenen op basis van de waarden voor socialists die we net berekend hebben. Voor leeftijd vragen we ook geen voorspellingen over de hele schaal, maar voor de leeftijden van 20 tot 80 met tussenstappen van 10 jaar.\n\n```{r}\n#voorspelde waarden\nbiden_int2_preds <- predictions(biden_int2, \n            newdata = datagrid(\n              socialists = c(9.72, 38.34, 66.96), \n              age = c(20,30,40,50,60,70,80))) \n\n#print resultaten\nbiden_int2_preds\n```\n\nDeze dataset heeft 21 observaties: 7 waarden voor age * 3 waarden voor socialists.\n\nWe plotten de voorspelde waarden zoals hiervoor met het `linetype` statement. We moeten de socialist variabele in de predictions dataset wel veranderen in een factor om het statement te kunnen gebruiken. We gebruiken hier de 'factor' functie gezien de data numeriek is en niet gelabeld (bij labels gebruiken we doorgaans factorize).\n\n```{r}\n#Class variabele\nclass(biden_int2_preds$socialists)\n\n#factor maken\nbiden_int2_preds <- biden_int2_preds |> \n  mutate(socialists = factor(socialists, \n                             levels = c(9.72, 38.34, 66.96), \n                             labels = c(\"1SD < Gemiddelde\", \"Gemiddelde\", \"1SD > Gemiddelde\")))\n```\n\nWe kunnen dan de plot maken op een vergelijkbare manier als eerder:\n\n```{r}\nggplot(biden_int2_preds, aes(x=age, y=estimate, linetype=socialists)) + \n  geom_line() + \n  geom_ribbon(aes(ymin=conf.low, ymax=conf.high), alpha = .2) + \n  labs(title = \"Voorspelde score voor Biden\", \n       y = \"Voorspelde score\", \n       x = \"Leeftijd\", \n       linetype= \"Voorkeur socialisten (hoger = meer voorkeur)\")\n```\n\n## Binaire x Binaire Interactie\n\nVoor een interactie met twee binaire variabelen gelden gelijkaardige principes.\n\nEen dergelijke interactie gebruiken we in het `biden_int3`-model, namelijk een interactie tussen (`right_track`) en `vote2016` (Clinton kiezer = 0, Trump kiezer = 1). Als controlevariabele voegen we `rural_urban` toe.\n\n```{r}\n#Model schatten en resultaten oplsaan\nbiden_int3 <- lm(biden ~ right_track * vote2016 + rural_urban, data = anes)\n\n#resultaten printen\ntidy(biden_int3)\n```\n\nWe gebruiken `predictions()` om voor alle combinaties van deze twee variabelen voorspelde waarden te berekenen. Dit resulteert in 4 voorspelde waarden: Clinton voter & \"right direction\", Clinton voter & \"wrong track\", Trump voter & \"right direction\", en Trump voter & \"wrong track\".\n\n```{r}\npredictions(\n  biden_int3, \n  by = c(\"right_track\", \"vote2016\"), \n  newdata = \"mean\")\n```\n\n\n`by = c(\"right_track\", \"vote2016\")`\n\n:   Om voorspelde waarden te verkrijgen voor alle categorieÃ«n van een binaire/categorische variabele kunnen we gebruik maken van de by = \"variable name\" optie. Gezien beide predictoren factor variabelen zijn duiden we ze beiden aan.\n\n`newdata = \"mean\")`\n\n:   Deze optie hebben we hier nodig (gezien we het 'by' statement gebruiken) om de overige onafhankelijke variabelen op hun gemiddelde of modus te houden.\n\nDe resultaten kunnen we in een plot visualiseren. De syntax is vrijwel hetzelfde als die voor plots van voorspelde waarden voor 1 factor variable (@sec-presenting-linear-regression-predicted-values-plots). We moeten gebruikmaken van `geom_pointrange()`. Nieuw is dat we voorspellingen onderscheiden van elkaar op basis van de waarden van de moderator via de `shape =` optie. Deze vertelt aan ggplot verschillende vormen te gebruiken voor de voorspelde waarden.[^interaction_03-3] \n\nVoor we plotten vertalen we de labels voor `vote2016` naar het Nederlands.\n\n[^interaction_03-3] Dit zou eventueel ook kunnen via kleuren (bv. `color = vote2016)`. Let er wel op dat niet iedereen kleuren kan zien (R heeft wel color-bind palettes beschikbaar). Bovendien kan een plot met kleuren onduidelijk worden afgedrukt in zwart/wit.\n\n```{r}\npredictions( #<1> \n  biden_int3, \n  by = c(\"right_track\", \"vote2016\"), \n  newdata = \"mean\") |> \n  ggplot(aes(x = right_track, y=estimate, shape = vote2016)) + \n  geom_pointrange(aes(ymin = conf.low, ymax = conf.high)) +  # <2>\n  geom_text(aes(label = round(estimate, 2), hjust=-0.2)) + \n  labs(title = \"Voorspelde score voor Biden\", \n       x = \"Richting van het land\", \n       y = \"Voorspelde score Biden\", \n       shape = \"Stemkeuze 2016\") + \n  scale_y_continuous(limits = c(0 , 100)) + #<3>\n    scale_x_discrete(labels = c(\"Wrong Track\" = \"Verkeerde richting\", \"Right Direction\" = \"Goede richting\"))\n```\n\n1.  We doen hier alles in 1 syntax-stap. We zouden dit in meerdere stappen kunnen opspitsen: eerst voorspellingen maken en oplsaan in data-object, dan data doorvoeren naar `ggplot()`.\n2.  Indien voorspelde waarden gelijkaardig zijn dan kunnen de markers overlappen. Om dit te verhelpen kun je de markers wat verplaatsen door `, position = position_dodge(width = 0.2)` toe te voegen aan het `geom_pointrange()` gedeelte, na het `aes()` gedeelte. De waarde waarmee markers verschoven worden (hier: 0.2) kun je veranderen.\n3.  We zetten de y-as op een schaal van 0 tot 100. Dit is niet strikt nodig, maar kan de figuur duidelijker maken.\n\n## Logistische regressie: voorbeeld\n\nBovenstaande syntax is ook van toepassing voor logistische regressie. Hier voorspellen we probabiliteiten in plaats van scores. In dit voorbeeld gebruiken we een `rightrack_int` model waarin we `rightrack` voorspellen en een interactie hebben tussen `vote2016` en `age`.\n\n```{r}\ntidy(righttrack_int)\n```\n\nWe berekenen de voorspelde kans dat een respondent vindt dat het land de goede richting uitgaat met combinaties van waarden voor `age` en `vote2016`. We maken voorspellingen, vertalen de labels en maken het plot:\n\n```{r}\nright_track_int_preds <-predictions(righttrack_int, \n            newdata = datagrid(age = seq(from=20,to=80, by=10), \n                               vote2016 = c(\"Trump Vote\", \"Clinton Vote\"))) |>\n  mutate(vote2016 = recode(vote2016, \n                       \"Clinton Vote\" = \"Clinton Stem\",\n                       \"Trump Vote\" = \"Trump Stem\"))\n  ggplot(right_track_int_preds, aes(x=age, y=estimate, linetype=vote2016)) + \n  geom_line() + \n  geom_ribbon(aes(ymin=conf.low, ymax=conf.high), alpha = 0.2) + \n  labs(title = \"Voorspelde kans dat respondent vindt dat het land de goede richting uitgaat\", \n       y = \"Voorspelde kans\", \n       x = \"Leeftijd\", \n       linetype = \"2016 Stemkeuze\") + \n  scale_y_continuous(limits=c(0,1)) \n```\n","srcMarkdownNoYaml":"\n\n# Voorspelde Waarden van Interactiemodellen {#sec-predicted-values-from-interaction-models}\n\n```{r}\n#| label: setup\n#| echo: false\n#| message: false\n#| warning: false\n\n#Packages\nlibrary(broom)        #Modelresultaten\nlibrary(rio)          #laden van data\nlibrary(tidyverse)    #datamanipulatie en grafieken\nlibrary(marginaleffects) #marginale effecten en voorspelde waarden berekenen\n\n#Data\nanes <- import(\"data/anes_interactions.rda\")\n\n#Modellen\nbiden_int <- lm(biden ~ pid * right_track + rural_urban, data = anes)\nrighttrack_int <- glm(right_track ~ vote2016 * age + rural_urban, \n                      family = \"binomial\", data = anes)\n```\n\n```{r}\n#| eval: false\n\n#Packages\nlibrary(broom)        #Modelresultaten\nlibrary(rio)          #laden van data\nlibrary(tidyverse)    #datamanipulatie en grafieken\nlibrary(marginaleffects) #marginale effecten en voorspelde waarden berekenen\n\n#Data\nanes <- import(\"data/anes_interactions.rda\")\n\n#Modellen\nbiden_int <- lm(biden ~ pid * right_track + rural_urban, data = anes)\nrighttrack_int <- glm(right_track ~ vote2016 * age + rural_urban, \n                      family = \"binomial\", data = anes)\n```\n\nWe kunnen marginale effecten gebruiken om interactie-effecten te verduidelijken zoals we in het vorige hoofdstuk gezien hebben. Maar we kunnen ook kijken naar voorspelde waarden (of kansen bij logistische regressie) van Y als een onafhankelijke variabele X en een onafhankelijke variable Z (de moderator) andere waarden aannemen. We gebruiken de `predictions()` functie uit het `marginaleffects` package. We bouwen verder op reeds geziene informatie in andere hoofdstukken (lineaire regressie: @sec-predicted-residual-values; logistische regressie: @sec-logit-predicted-probabilities).\n\n## Binaire X Continue Interactie\n\nWe hebben reeds een model geschat waarbij scores voor kandidaat Biden voorspeld worden met een interactie van partij-identificatie (pid) en perceptie over de richting dat het land uitgaat (right_track).\n\nOp basis van dit model (biden_int), berekenen we nu met `predictions()` de voorspelde waarden voor elke combinatie van waarden voor de 2 onafhankelijke variabelen in de interactie (bv. pid = 1 & right_track = \"Right Direction\", pid = 1 & right_track = \"Wrong Track\", pid = 2 & right_track = \"Right Direction\"...). Als er te veel waarden zouden zijn om realistisch op deze manier te werk te gaan dan kiezen we voorspellingen op basis van een subset van waarden (bv. minimum, gemiddelde, maximum).\n\nAndere onafhankelijke variabelen in het model worden op hun gemiddelde (continue variabelen) of modus (factor variabelen) gehouden.\n\n```{r}\n#Voorspelde waarden berekenen en opslaan in data object\nbiden_int_preds <- predictions(biden_int, \n            newdata = datagrid(pid = c(1,2,3,4,5,6,7), \n                               right_track = c(\"Right Direction\", \"Wrong Track\")))\n\n```\n\n`biden_int_preds <- predictions(biden_int,`\n\n:   We passen de functie 'predictions' toe op het model tussen haakjes en slaan de resultaten op in een data object (\"biden_int_preds\") dat we later weer kunnen gebruiken.\n\n`newdata = datagrid(pid = c(1,2,...7), right_track = c(\"Right Direction\", \"Wrong Track\")))`\n\n:   We duiden de gewenste waarden van de predictoren aan waarvoor voorspellingen berekend zullen worden met de \"newdata = datagrid()\" optie. We duiden alle waarden voor pid aan (1 tot 7) en de 2 mogelijke waarden voor right_track (Right Direction or Wrong Track).[^interaction_03-1] In eigen toepassingen wordt dit aangepast volgens de eigen variabelen.\n\n[^interaction_03-1]: De waarden voor pid zouden we ook als volgt kunnen aanduiden: `pid = c(1:7)`.\n\nDe dataset die we verkrijgen heeft 14 rijen met voorspelde waarden: 7 (waarden voor `pid`) * 2 (waarden voor `right_track`).\n\n```{r}\n# print resultaten\nbiden_int_preds\n```\n\nDe voorspellingen kunnen we visueel presenteren in een plot. Het proces dat we volgen is vrijwel hetzelfde als wat we doen voor een model zonder interactie (zie @sec-presenting-linear-regression-predicted-values-plots). Er is echter een belangrijke toevoeging: het `linetype` gedeelte van de syntax, dat enkel gebruikt kan worden indien er een factor variabele is. \n\nVoor we het plot produceren veranderen we de waarden voor right_track naar het Nederlands zodat ze correct worden weergegeven op het plot. Net zoals bij marginale effecten zouden we de code voor predictions (hierboven) ook kunnen combineren met de `ggplot` code via de pipe operator.\n\n```{r}\nbiden_int_preds |>\n  mutate(right_track = recode(right_track, \n                       \"Wrong Track\" = \"Verkeerde richting\",\n                       \"Right Direction\" = \"Goede richting\")) |>\nggplot(aes(x=pid, y=estimate, linetype = right_track)) + \n  geom_line() + \n  geom_ribbon(aes(ymin=conf.low, ymax=conf.high), alpha = 0.2) + \n  labs(title = \"Voorspelde score voor Biden\", \n       x = \"Partij-identificatie\", \n       y = \"Voorspelde waarden\", \n       linetype = \"Richting land\" ) + \n  scale_x_continuous(breaks=c(1,2,3,4,5,6,7))\n```\n\n`ggplot(..., linetype = right_track)) + geom_line() + geom_ribbon(...) +`\n\n:   Dit gedeelte van de syntax is grotendeels ook al gebruikt in eerdere weken. Een belangrijke toevoeging is `linetype = right_track`. Zo vragen we `ggplot()` om de voorspelde waarden voor elke categorie van \"right_track\" weer te geven als verschillende lijnen. We zouden de voorspellingen ook kunnen onderscheiden op een andere manier, bv. met kleur (`color = right_track`). De `linetype` (en `color`) functies werken enkel met factor variabelen. De variabele `right_track`is hier reeds een factor dus we hebben geen verdere data management stappen moeten ondernemen. Zie @sec-linetype-error voor meer informatie.\n\n## Continue X Continue Interactie\n\nOm voorspelde waarden voor interacties tussen continue variabelen te berekenen en te plotten, is het proces iets ingewikkelder, omdat er veel mogelijke combinaties van waarden zijn om voorspellingen voor te maken.\n\nIn het vorige hoofdstuk hebben we het `biden_int2` model gebruikt om Biden scores te voorspellen met een interactie tussen `age` en `socialists`. We schatten dat model opnieuw hieronder.\n\n\n```{r}\n#Model schatten en resultaten opslaan\nbiden_int2 <- lm(biden ~ socialists * age + rural_urban, data = anes)\n\n#resultaten bekijekn\ntidy(biden_int2)\n```\n\nBeide variabelen kunnen veel mogelijke waarden aannemen. We zouden voorspellingen kunnen maken voor waarden van 0 tot 100 voor `socialists` met intervallen van 10, en van 20 tot 80 voor `age`met intervallen van 10. Dit zou ons echter veel waarden opleveren die we moeilijk zouden kunnen plotten (en begrijpen). \n\nWat vaak gebeurt in de praktijk is dat we 1 van de 2 predictoren kiezen en voorspellingen maken voor 3 waarden: het gemiddelde, 1 standaarddeviatie (SD) onder het gemiddelde en 1 standaarddeviatie (SD) boven het gemiddelde. De continue variabele zal eigenlijk getransformeerd worden in een factor met 3 waarden. Zo kunnen we een plot maken met 3 lijnen. We transformeren doorgaans de moderator (Z).\n\nVoor het 'biden_int2' model, nemen we nu (bij wijze van voorbeeld) socialists als de moderator. Eerst berekenen we de drie relevante waarden (gemiddelde, 1 SD daaronder, 1 SD daarboven). Deze statistieken moeten we berekenen op basis van de observaties gebruikt in het model. Dit zijn niet altijd het aantal observaties in de dataset door missende waarden op andere variabelen. Als tussenstap gebruiken we hier de `predictions()` functie van het `marginaleffects` package gezien deze functie een nieuwe dataset creÃ«ert met alle complete observaties. [^interaction_03-2]\n\n[^interaction_03-2]: We zouden ook de originele dataset (`anes`) kunnen nemen, missing waarden voor de variabelen gebruikt in het model wegfilteren en de juiste statistieken berekenen: `anes \\|\\> filter(complete.cases(biden, socialists, age, rural_urban)) \\|\\> summarize(...)`.`predictions()` combineert deze stappen voor ons.\n\n```{r}\npredictions(biden_int2) |>   #nieuw dataobject met complete observaties\n  summarise(\n    mean_below = mean(socialists) - sd(socialists), #1 SD onder gemiddelde\n    mean = mean(socialists),                        #gemiddelde\n    mean_above = mean(socialists) + sd(socialists)) #1 SD boven gemiddelde\n```\n\nNu kunnen we de voorspelde waarden berekenen op basis van de waarden voor socialists die we net berekend hebben. Voor leeftijd vragen we ook geen voorspellingen over de hele schaal, maar voor de leeftijden van 20 tot 80 met tussenstappen van 10 jaar.\n\n```{r}\n#voorspelde waarden\nbiden_int2_preds <- predictions(biden_int2, \n            newdata = datagrid(\n              socialists = c(9.72, 38.34, 66.96), \n              age = c(20,30,40,50,60,70,80))) \n\n#print resultaten\nbiden_int2_preds\n```\n\nDeze dataset heeft 21 observaties: 7 waarden voor age * 3 waarden voor socialists.\n\nWe plotten de voorspelde waarden zoals hiervoor met het `linetype` statement. We moeten de socialist variabele in de predictions dataset wel veranderen in een factor om het statement te kunnen gebruiken. We gebruiken hier de 'factor' functie gezien de data numeriek is en niet gelabeld (bij labels gebruiken we doorgaans factorize).\n\n```{r}\n#Class variabele\nclass(biden_int2_preds$socialists)\n\n#factor maken\nbiden_int2_preds <- biden_int2_preds |> \n  mutate(socialists = factor(socialists, \n                             levels = c(9.72, 38.34, 66.96), \n                             labels = c(\"1SD < Gemiddelde\", \"Gemiddelde\", \"1SD > Gemiddelde\")))\n```\n\nWe kunnen dan de plot maken op een vergelijkbare manier als eerder:\n\n```{r}\nggplot(biden_int2_preds, aes(x=age, y=estimate, linetype=socialists)) + \n  geom_line() + \n  geom_ribbon(aes(ymin=conf.low, ymax=conf.high), alpha = .2) + \n  labs(title = \"Voorspelde score voor Biden\", \n       y = \"Voorspelde score\", \n       x = \"Leeftijd\", \n       linetype= \"Voorkeur socialisten (hoger = meer voorkeur)\")\n```\n\n## Binaire x Binaire Interactie\n\nVoor een interactie met twee binaire variabelen gelden gelijkaardige principes.\n\nEen dergelijke interactie gebruiken we in het `biden_int3`-model, namelijk een interactie tussen (`right_track`) en `vote2016` (Clinton kiezer = 0, Trump kiezer = 1). Als controlevariabele voegen we `rural_urban` toe.\n\n```{r}\n#Model schatten en resultaten oplsaan\nbiden_int3 <- lm(biden ~ right_track * vote2016 + rural_urban, data = anes)\n\n#resultaten printen\ntidy(biden_int3)\n```\n\nWe gebruiken `predictions()` om voor alle combinaties van deze twee variabelen voorspelde waarden te berekenen. Dit resulteert in 4 voorspelde waarden: Clinton voter & \"right direction\", Clinton voter & \"wrong track\", Trump voter & \"right direction\", en Trump voter & \"wrong track\".\n\n```{r}\npredictions(\n  biden_int3, \n  by = c(\"right_track\", \"vote2016\"), \n  newdata = \"mean\")\n```\n\n\n`by = c(\"right_track\", \"vote2016\")`\n\n:   Om voorspelde waarden te verkrijgen voor alle categorieÃ«n van een binaire/categorische variabele kunnen we gebruik maken van de by = \"variable name\" optie. Gezien beide predictoren factor variabelen zijn duiden we ze beiden aan.\n\n`newdata = \"mean\")`\n\n:   Deze optie hebben we hier nodig (gezien we het 'by' statement gebruiken) om de overige onafhankelijke variabelen op hun gemiddelde of modus te houden.\n\nDe resultaten kunnen we in een plot visualiseren. De syntax is vrijwel hetzelfde als die voor plots van voorspelde waarden voor 1 factor variable (@sec-presenting-linear-regression-predicted-values-plots). We moeten gebruikmaken van `geom_pointrange()`. Nieuw is dat we voorspellingen onderscheiden van elkaar op basis van de waarden van de moderator via de `shape =` optie. Deze vertelt aan ggplot verschillende vormen te gebruiken voor de voorspelde waarden.[^interaction_03-3] \n\nVoor we plotten vertalen we de labels voor `vote2016` naar het Nederlands.\n\n[^interaction_03-3] Dit zou eventueel ook kunnen via kleuren (bv. `color = vote2016)`. Let er wel op dat niet iedereen kleuren kan zien (R heeft wel color-bind palettes beschikbaar). Bovendien kan een plot met kleuren onduidelijk worden afgedrukt in zwart/wit.\n\n```{r}\npredictions( #<1> \n  biden_int3, \n  by = c(\"right_track\", \"vote2016\"), \n  newdata = \"mean\") |> \n  ggplot(aes(x = right_track, y=estimate, shape = vote2016)) + \n  geom_pointrange(aes(ymin = conf.low, ymax = conf.high)) +  # <2>\n  geom_text(aes(label = round(estimate, 2), hjust=-0.2)) + \n  labs(title = \"Voorspelde score voor Biden\", \n       x = \"Richting van het land\", \n       y = \"Voorspelde score Biden\", \n       shape = \"Stemkeuze 2016\") + \n  scale_y_continuous(limits = c(0 , 100)) + #<3>\n    scale_x_discrete(labels = c(\"Wrong Track\" = \"Verkeerde richting\", \"Right Direction\" = \"Goede richting\"))\n```\n\n1.  We doen hier alles in 1 syntax-stap. We zouden dit in meerdere stappen kunnen opspitsen: eerst voorspellingen maken en oplsaan in data-object, dan data doorvoeren naar `ggplot()`.\n2.  Indien voorspelde waarden gelijkaardig zijn dan kunnen de markers overlappen. Om dit te verhelpen kun je de markers wat verplaatsen door `, position = position_dodge(width = 0.2)` toe te voegen aan het `geom_pointrange()` gedeelte, na het `aes()` gedeelte. De waarde waarmee markers verschoven worden (hier: 0.2) kun je veranderen.\n3.  We zetten de y-as op een schaal van 0 tot 100. Dit is niet strikt nodig, maar kan de figuur duidelijker maken.\n\n## Logistische regressie: voorbeeld\n\nBovenstaande syntax is ook van toepassing voor logistische regressie. Hier voorspellen we probabiliteiten in plaats van scores. In dit voorbeeld gebruiken we een `rightrack_int` model waarin we `rightrack` voorspellen en een interactie hebben tussen `vote2016` en `age`.\n\n```{r}\ntidy(righttrack_int)\n```\n\nWe berekenen de voorspelde kans dat een respondent vindt dat het land de goede richting uitgaat met combinaties van waarden voor `age` en `vote2016`. We maken voorspellingen, vertalen de labels en maken het plot:\n\n```{r}\nright_track_int_preds <-predictions(righttrack_int, \n            newdata = datagrid(age = seq(from=20,to=80, by=10), \n                               vote2016 = c(\"Trump Vote\", \"Clinton Vote\"))) |>\n  mutate(vote2016 = recode(vote2016, \n                       \"Clinton Vote\" = \"Clinton Stem\",\n                       \"Trump Vote\" = \"Trump Stem\"))\n  ggplot(right_track_int_preds, aes(x=age, y=estimate, linetype=vote2016)) + \n  geom_line() + \n  geom_ribbon(aes(ymin=conf.low, ymax=conf.high), alpha = 0.2) + \n  labs(title = \"Voorspelde kans dat respondent vindt dat het land de goede richting uitgaat\", \n       y = \"Voorspelde kans\", \n       x = \"Leeftijd\", \n       linetype = \"2016 Stemkeuze\") + \n  scale_y_continuous(limits=c(0,1)) \n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"interaction_03.html"},"language":{"toc-title-document":"Inhoudsopgave","toc-title-website":"Op deze pagina","related-formats-title":"Andere formaten","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Bron","other-links-title":"Andere Links","code-links-title":"Code Links","launch-dev-container-title":"Dev Container starten","launch-binder-title":"Binder starten","article-notebook-label":"Artikel Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Broncode downloaden","notebook-preview-back":"Terug naar Artikel","manuscript-meca-bundle":"MECA Archief","section-title-abstract":"Samenvatting","section-title-appendices":"Bijlagen","section-title-footnotes":"Voetnoten","section-title-references":"Referenties","section-title-reuse":"Hergebruik","section-title-copyright":"Auteursrechten","section-title-citation":"Citaat","appendix-attribution-cite-as":"Citeer dit werk als:","appendix-attribution-bibtex":"BibTeX citaat:","appendix-view-license":"Licentie Bekijken","title-block-author-single":"Auteur","title-block-author-plural":"Auteurs","title-block-affiliation-single":"Affiliatie","title-block-affiliation-plural":"Affiliaties","title-block-published":"Publicatiedatum","title-block-modified":"Gewijzigd","title-block-keywords":"Trefwoorden","callout-tip-title":"Tip","callout-note-title":"Opmerking","callout-warning-title":"Waarschuwing","callout-important-title":"Belangrijk","callout-caution-title":"Opgelet","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Alle code tonen","code-tools-hide-all-code":"Alle code verbergen","code-tools-view-source":"Broncode bekijken","code-tools-source-code":"Broncode","tools-share":"Share","tools-download":"Download","code-line":"Regel","code-lines":"Regels","copy-button-tooltip":"Kopieer naar klembord","copy-button-tooltip-success":"Gekopieerd!","repo-action-links-edit":"Pagina bewerken","repo-action-links-source":"Broncode bekijken","repo-action-links-issue":"Een probleem melden","back-to-top":"Terug naar boven","search-no-results-text":"Geen resultaten","search-matching-documents-text":"Gevonden documenten","search-copy-link-title":"Kopieer link om te zoeken","search-hide-matches-text":"Extra overeenkomsten verbergen","search-more-match-text":"meer overeenkomst in dit document","search-more-matches-text":"meer overeenkomsten in dit document","search-clear-button-title":"Wissen","search-text-placeholder":"","search-detached-cancel-button-title":"Annuleren","search-submit-button-title":"Verzenden","search-label":"Zoeken","toggle-section":"Schakel sectie","toggle-sidebar":"Schakel zijbalknavigatie","toggle-dark-mode":"Schakel donkere modus","toggle-reader-mode":"Schakel leesmodus","toggle-navigation":"Schakel navigatie","crossref-fig-title":"Figuur","crossref-tbl-title":"Tabel","crossref-lst-title":"Listing","crossref-thm-title":"Stelling","crossref-lem-title":"Lemma","crossref-cor-title":"Conclusie","crossref-prp-title":"Voorstel","crossref-cnj-title":"Aanname","crossref-def-title":"Definitie","crossref-exm-title":"Voorbeeld","crossref-exr-title":"Oefening","crossref-ch-prefix":"Hoofdstuk","crossref-apx-prefix":"Bijlage","crossref-sec-prefix":"Paragraaf","crossref-eq-prefix":"Vergelijking","crossref-lof-title":"Lijst van figuren","crossref-lot-title":"Lijst van tabellen","crossref-lol-title":"Lijst van listings","environment-proof-title":"Bewijs","environment-remark-title":"Opmerking","environment-solution-title":"Oplossing","listing-page-order-by":"Sorteer op","listing-page-order-by-default":"Standaard","listing-page-order-by-date-asc":"Oudste","listing-page-order-by-date-desc":"Nieuwste","listing-page-order-by-number-desc":"Aflopend","listing-page-order-by-number-asc":"Oplopend","listing-page-field-date":"Datum","listing-page-field-title":"Titel","listing-page-field-description":"Beschrijving","listing-page-field-author":"Auteur","listing-page-field-filename":"Bestandsnaam","listing-page-field-filemodified":"Gewijzigd","listing-page-field-subtitle":"Subtitel","listing-page-field-readingtime":"Leestijd","listing-page-field-wordcount":"Woordentelling","listing-page-field-categories":"CategorieÃ«n","listing-page-minutes-compact":"{0} min","listing-page-category-all":"Alle","listing-page-no-matches":"Geen overeenkomsten","listing-page-words":"{0} woorden","listing-page-filter":"Filter","draft":"Ontwerp"},"metadata":{"lang":"nl","fig-responsive":true,"quarto-version":"1.5.57","bibliography":["references.bib"],"editor":"visual","theme":{"light":"cosmo","dark":"darkly"},"code-annotations":"hover"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}