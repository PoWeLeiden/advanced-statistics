{
  "hash": "8daee4911492964a7225b92870eb628f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ncode-annotations: hover\ncitation-location: margin\n---\n\n\n\n# Marginale Effecten {#sec-marginal-effects}\n\n\n\n::: {.cell}\n\n:::\n\n\n\nIn het vorige hoofdstuk leerden we een logistisch regressiemodel schatten en interpreteren met behulp van de coëfficiënten en odds ratios. Beide zijn echter niet erg intuïtief. Wat we vaak echt willen weten is hoeveel de kans op Y=1 verandert als de onafhankelijke variabele met 1 eenheid stijgt. We kunnen naar de marginale effecten van onze onafhankelijke variabelen kijken om iets te zeggen over de verandering in de *probabiliteit* dat Y=1. We gebruiken hiervoor functies uit het `marginaleffects` package.\n\nWe gebruiken volgende packages en data:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Packages\nlibrary(rio)             #laden van data\nlibrary(tidyverse)       #datamanipulatie en grafieken\nlibrary(marginaleffects) #voorspelde waarden en marginale effecten berekenen\n\n#Data\nESS9NL <- import(\"ESS9e03, Netherlands.sav\")\n```\n:::\n\n\n\n## Data Management, voorbeeldmodel, en problemen met `factorize()`\n\nWe maken gebruiken van eenzelfde model dat we gebruikt hebben in vorig hoofdstuk. Daarin voorspelden we stemmen op basis van gender, leeftijd, vertouwen in politici en linsk-rechtsideologie. We herhalen eerst een paar data management stappen:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Datamanagement\nESS9NL <- ESS9NL |>\n  #Factor maken van categorische variabelen\n  mutate(gndr_F = factorize(gndr), # <1> \n         vote_F = factorize(vote))  |> \n  #Not Eligible op missing zetten\n  mutate(vote_F = na_if(vote_F,\"Not eligible to vote\")) |> # <1> \n  #Relevel van variabelen\n  mutate(vote_F = relevel(vote_F, \"No\"), \n         gndr_F = relevel(gndr_F, \"Female\"))\n\n#Het model\nVote_model_mp <- glm(vote_F ~ gndr_F + agea + trstplt + lrscale, \n                data = ESS9NL, family = \"binomial\")\n\n#Resultaten printen\nsummary(Vote_model_mp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nglm(formula = vote_F ~ gndr_F + agea + trstplt + lrscale, family = \"binomial\", \n    data = ESS9NL)\n\nCoefficients:\n             Estimate Std. Error z value Pr(>|z|)    \n(Intercept) -0.284194   0.380455  -0.747    0.455    \ngndr_FMale   0.043281   0.154201   0.281    0.779    \nagea         0.018349   0.004503   4.075 4.61e-05 ***\ntrstplt      0.195020   0.038706   5.039 4.69e-07 ***\nlrscale      0.029257   0.039306   0.744    0.457    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 1173.9  on 1424  degrees of freedom\nResidual deviance: 1135.3  on 1420  degrees of freedom\n  (248 observations deleted due to missingness)\nAIC: 1145.3\n\nNumber of Fisher Scoring iterations: 4\n```\n\n\n:::\n:::\n\n\n\n1.  We zouden ook deze 3 `mutate()` stappen in 1 stap kunnen combineren.\n\nHet `marginaleffects`package is niet volledig compatibel met de `factorize` functie die we hierboven hebben gebruikt voor gender. Laten we even kijken naar de `gndr_F`variabele:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlevels(ESS9NL$gndr_F)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Female\"    \"Male\"      \"No answer\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntable(ESS9NL$gndr_F)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n   Female      Male No answer \n      840       833         0 \n```\n\n\n:::\n:::\n\n\n\nEr zijn 3 niveaus of levels voor `gndr_F`: \"Female\", \"Male\", en \"No Answer\". Er vallen echter 0 respondenten onder \"No Answer\". In dergelijke situaties zal onderstaande functie een error geven omdat de functie zoekt naar een derde niveau dat er niet is.\n\nOm dit te voorkomen kunnen we gebruik maken van de `droplevels()` functie om lege niveaus te verwijderen. Of we gebruiken `factor()` ipv `factorize`om `gndr` een factor variabele te maken. Zie. @sec-slopes-error in de Veelvoorkomende Fouten Appendix voor meer informatie.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Drop levels: verwijderen van categorieën zonder observaties\nESS9NL <- ESS9NL |>\n  mutate(gndr_F = droplevels(gndr_F))\n\n#Checken van syntax\nlevels(ESS9NL$gndr_F)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Female\" \"Male\"  \n```\n\n\n:::\n\n```{.r .cell-code}\ntable(ESS9NL$gndr_F)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nFemale   Male \n   840    833 \n```\n\n\n:::\n:::\n\n\n\n## Gemiddelde Marginale Effecten (AME)\n\nDe eerste soort marginale effecten die we bekijken zijn de gemiddelde marginale effecten: de Average Marginal Effects (AME). We gebruiken hiervoor de `avg_slopes()` functie uit `marginaleffects`. De AME geeft de gemiddelde verandering in probabiliteit dat Y=1 weer (in termen van percentpunten) als de onafhankelijke met 1 eenheid omhoog gaat (dy/dx). We bereken het marginale effect voor elke observatie en elke variabele in het model en nemen dan het gemiddelde per variabele. Deze figuur beschrijft het proces (uit @heiss2022):\n\n![AME berekening door avg_slopes](figures/flow-ame.png)\n\nLaten we kijken naar de AMEs van ons model:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Schatten van AMEs obv model\nAME <- avg_slopes(Vote_model_mp,\n                  conf_level = 0.95)\n```\n:::\n\n\n\nDe syntax lees je zo\n\n`AME <- avg_slopes(Vote_model_mp,`\n\n:   We gebruiken de functie avg_slopes op het model tussen haakjes. De resultaten slaan we op in een nieuw data object (AME).\n\n`conf_level = 0.95)`\n\n:   Standaard wordt een betrouwbaarheidsniveau van 95% gebruikt, dus deze code kan weggelaten worden als dit het gewenste niveau is. Met de code kun je het niveau ook veranderen (bv. 0.99).\n\nDit is de output:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(AME) # <1> \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 9\n  term  contrast estimate std.error statistic p.value s.value conf.low conf.high\n  <chr> <chr>       <dbl>     <dbl>     <dbl>   <dbl>   <dbl>    <dbl>     <dbl>\n1 agea  dY/dX     0.00220  0.000538     4.08  4.47e-5  14.4    0.00114   0.00325\n2 gndr… Male - …  0.00518  0.0185       0.281 7.79e-1   0.360 -0.0310    0.0414 \n3 lrsc… dY/dX     0.00350  0.00470      0.744 4.57e-1   1.13  -0.00571   0.0127 \n4 trst… dY/dX     0.0233   0.00460      5.07  3.92e-7  21.3    0.0143    0.0323 \n```\n\n\n:::\n:::\n\n\n\n1.  We zouden `AME` kunnen typen eerder dan `tibble(AME)` maar dit geeft andere kolomnamen. We gebruiken `tibble()` om de kolomnamen te zien zoals ze ook in de dataset zijn opgeslagen. Zie de waarschuwing hiervover in Hoofdstuk 5 @sec-predicted-residual-values.\n\n::: callout-note\n#### Output uitleg\n\n-   `term`: bevat de namen van de variabelen (bv., `agea`, `gndr_F`, etc.).\n-   `contrast`: Het 'contrast' duidt aan welke vergelijking gemaakt wordt: 1 eenheid toename voor continue variabelen, een verandering van categorie voor factor variabelen.\n-   `estimate`: De AME\n-   `std.error` t.e.m. `conf.high`: Informatie over de onzekerheid van de schatting.\n:::\n\n::: callout-warning\n#### Interpretatie\n\nDe gemiddelde marginale effecten (AMEs) geven weer wat de gemiddelde verandering is in de probabiliteit dat Y=1 (in percentpunten) als X met 1 eenheid stijgt. De percentpunten verkrijg je door de AME schatting te vermenigvuldigen met 100. Bijvoorbeeld:\n\n-   De kans om te stemmen is gemiddeld 0.5 percentpunten hoger voor een mannelijke respondent dan voor een vrouwelijke respondent.\n-   De kans om te stemmen stijgt gemiddeld met 2.3 percentpunten met elke eenheid dat respondenten meer vertrouwen hebben in politici.\n:::\n\n## Effecten op gemiddelde waarden van de predictors (MEM)\n\nWe raden aan om AME te gebruiken als je marginale effecten op basis van een logistische regressie interpreteert. Echter zie je ook soms onderzoek waarin men gebruik maakt van \"effecten op gemiddelde waarden\": \"marginal effect at the mean\" of MEM. Daarmee berekenen we het effect op de probabiliteit dat Y=1 wanneer predictors hun gemiddelde waarden aannemen, of de modus bij categorische variabelen. Deze figuur beschrijft de berekening (uit @heiss2022):\n\n![He avg_slopes de MEM berekent](figures/flow-mem.png)\n\nDe syntax wordt licht aangepast voor de MEM;\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMEM <- slopes(Vote_model_mp, \n              conf_level = 0.95,\n              newdata = datagrid()\n              )\n```\n:::\n\n\n\n`newdata = datagrid()`\n\n:   We maken een nieuwe dataset voor de berekening waarin alle onafhankelijke variabelen op hun gemiddelde of modus worden gehouden.\n\nLaten we kijken naar de resultaten:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(MEM)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 18\n  rowid term    contrast   estimate std.error statistic p.value s.value conf.low\n  <int> <chr>   <chr>         <dbl>     <dbl>     <dbl>   <dbl>   <dbl>    <dbl>\n1     1 agea    dY/dX       0.00210  0.000519     4.05  5.07e-5  14.3    0.00109\n2     1 gndr_F  Male - Fe…  0.00504  0.0180       0.281 7.79e-1   0.360 -0.0302 \n3     1 lrscale dY/dX       0.00336  0.00453      0.742 4.58e-1   1.13  -0.00551\n4     1 trstplt dY/dX       0.0224   0.00447      5.00  5.67e-7  20.8    0.0136 \n# ℹ 9 more variables: conf.high <dbl>, predicted_lo <dbl>, predicted_hi <dbl>,\n#   predicted <dbl>, gndr_F <fct>, agea <dbl>, trstplt <dbl>, lrscale <dbl>,\n#   vote_F <fct>\n```\n\n\n:::\n:::\n\n\n\nBehalve estimate, standaardfout, test statistiek, p-waarde, en onder- en bovengrens van de betrouwbaarheidsintervallen, bevat de MEM dataset ook de gemiddelden en/of modus waarden voor de predictoren.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMEM |> \n  select(gndr_F, agea, trstplt, lrscale) |> \n  as_tibble()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 4\n  gndr_F  agea trstplt lrscale\n  <fct>  <dbl>   <dbl>   <dbl>\n1 Male    50.7    5.34    5.15\n2 Male    50.7    5.34    5.15\n3 Male    50.7    5.34    5.15\n4 Male    50.7    5.34    5.15\n```\n\n\n:::\n:::\n\n\n\n::: callout-warning\n#### Interpretatie\n\nDe interpretatie van MEMs is gelijkaardig aan die van AME: Welke gemiddelde verandering in de kans dat Y=1 verwachten we als X 1 eenheid stijgt? Vermenigvuldigen met 100 leidt tot een interpretatie in termen van percentpunten. De gemiddelde verandering is nu wel berekend wanneer onafhankelijke variabelen hun gemiddelde waarden aannemen. Dit moet gerapporteerd worden. Bijvoorbeeld: mannelijke respondenten hebben een 0.5 percentpunten hogere kans om te stemmen dan vrouwelijke respondenten, als leeftijd, ideologie, en vertrouwen in politici constant worden gehouden op hun gemiddelde waarde.\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}